<p align="middle" >
  <img width="200px;" src="https://user-images.githubusercontent.com/50367798/106415730-2645a280-6493-11eb-876c-ef7172652261.png"/>
</p>
<h2 align="middle">자동차 경주 게임</h2>
<p align="middle">자바스크립트로 구현 하는 자동차 경주 게임</p>

# 📄 Step1 개요

콘솔에서 동작하는 자동차 경주 게임을 구현한다.

# 📍 Step1 목표

0. 결과만큼 과정이 중요함을 명심하며, 제대로 고민한다.
1. 내가 정의한 TDD cycle을 적용하며, 문제점을 찾아본다.
2. 간단한 핵심 기능부터 순차적으로 복잡도를 높이며 디테일을 잡는다.
3. 의존성을 고려하며 테스트 코드를 작성한다.

## 📄 3분 요약

안녕하세요. 멘토님, 늦어서 죄송합니다.
가감없는 피드백 부탁드립니다. 많이 배워가겠습니다 🥊

-   이번 자동차미션은 `역할과 책임에 따라 코드를 잘 분리하자`를 핵심 목표로 진행했습니다. 역할과 책임 단위로 코드를 분리하지 않아 작성하다보니, 가독성도 낮고 유지보수나 디버깅도 어려웠기 때문입니다.

-   역할과 책임에 따라 코드를 분리하기 위해, 아래 흐름으로 미션을 설계-진행하였습니다.
    (1) [역할과 책임에 따라 MVC 세 영역으로 코드 분리하기]()
    (2) [객체 간 협력 관계 설계]()
    (3) [적절한 형태의 구현 방식 선택]()

-   또한 특정 디자인 패턴 적용 전, As-Is vs To-Be 비교해 trade-off 따져 보아 꼭 필요한 경우만 패턴을 적용했습니다.

-   미션을 진행하며, 의문이 들었던 부분을 `고민했던 지점 및 연관 질문 부분`에 정리해 두었으니 점검 부탁드립니다.
    **[질문 리스트]**
    ✅ 에러 발생의 책임과 에러 처리의 책임이 적절히 분리되고, 각각 잘 처리되고 있는지
    ✅ 작성한 코드 중 더 나은 구현 방식이 있는지
    ✅ 오버엔지니어링이 없는지

## 💭 도메인 영역과 UI 영역 분리 위해 MVC 패턴 도입 결정

-   **_[Before] MVC 도입 전_**

    -   하나의 클래스 안에 UI 영역과 도메인 영역의 코드가 혼재되어 아래 문제들이 발생했습니다.

        1. 클래스 간의 `높은 코드 결합도`로 변경과 확장에 취약
        2. `낮은 가독성`으로 코드 이해가 어려워 유지 보수 어려움
        3. `낮은 코드 재사용성`

-   **_[After] MVC 도입_**

    -   도입 목적: `책임 소재를 명확히 하여 변경과 확장 유지보수에 좋은 구조 설계`

        -   app 내 코드를 `목적`에 따라 UI 영역(View)과 도메인 영역(Model)으로 분리
        -   프로그램 흐름에 따라 View, Model에 명령 내리는 역할 Controller로 분리

    -   MVC 도입하며, 코드 작성 시 신경 쓴 부분
        ✅ Model, View, Controller 각각의 `목적`에 따라 클래스에 코드를 분할하였습니다.

        -   Model : 상태값을 가지고 이를 변경하거나 반환하는 코드
        -   View : 사용자 인터페이스를 통해 입출력을 수행하는 코드
        -   Controller : (1) 프로그램 흐름에 따라 Model에게는 데이터 처리 명령을 (2) View에게는 입출력 명령을 내리는 코드

        ✅ Model, View, Controller 사이의 의존성을 신경쓰며 상태를 관리했습니다.

        -   Model은 Controller와 View에 의존하지 않음
        -   View는 Model에만 의존하고, Controller에 의존해서는 안됨
        -   Controller는 Model과 View에 의존해도 됨

    -   도입 결과
        -   `목적`에 따라 Model, View, Controller 역할을 수행하는 별도의 객체로 분리
            -   가독성 향상되어 다른 개발자 뿐 아니라 내가 코드를 이해하는 속도 빨라짐
            -   각 클래스 간의 코드 결합도가 낮아져 변경과 확장이 쉬운 코드로 변화

## 👩‍🎨 객체 간 협력 구조 설계

-   도메인 영역(Model)에서 (1) 요구 사항을 분석하고 (2) 책임 단위로 객체를 생성하여 (3) 기능 구현을 위한 객체 간의 협력 관계를 구성했습니다.
-   [객체 간 협력 관계 구축 cycle]()에 따라 객체 간 협력 관계도를 그렸습니다.(그림 넣기)

## 🔧 적절한 구현 방식 선택

-   [클래스로 작성해야하는 기준]()을 세워, 꼭 필요한 경우만 클래스로 구현하였습니다.
    -   클래스와 결합하는 경우만 `static` 키워드 사용
    -   되도록 `private` 키워드로 캡슐화
    -   객체 간 협력 과정에 필요한 메소드만 공용 인터페이스로 구현
-   ## [함수 선언 방식 기준]()을 세워, side-effect 없이 목적에 맞게 함수를 정의하였습니다.
